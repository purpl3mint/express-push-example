// Register a Service Worker.
navigator.serviceWorker.register('service-worker.js');

navigator.serviceWorker.ready
.then(function(registration) {
  // Use the PushManager to get the user's subscription to the push service.
  if (!registration.pushManager){
    throw new Error("Push notifications not supported");
  }
  return registration.pushManager.getSubscription()
  .then(async function(subscription) {
    // If a subscription was found, return it.
    if (subscription) {
      return subscription;
    }

    // Get the server's public key
    const response = await fetch('./vapidPublicKey');
    const vapidPublicKeyRaw = await response.text();
    const vapidPublicKey = JSON.parse(vapidPublicKeyRaw).message;
    // Chrome doesn't accept the base64-encoded (string) vapidPublicKey yet
    // urlBase64ToUint8Array() is defined in /tools.js
    const convertedVapidKey = urlBase64ToUint8Array(vapidPublicKey);

    // Otherwise, subscribe the user (userVisibleOnly allows to specify that we don't plan to
    // send notifications that don't have a visible effect for the user).
    return registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: convertedVapidKey
    });
  });
}).then(function(subscription) {
  // Send the subscription details to the server using the Fetch API.
  fetch('./registerPush', {
    method: 'post',
    headers: {
      'Content-type': 'application/json'
    },
    body: JSON.stringify({
      subscription: subscription
    }),
  }).catch(e => console.log(e));

  document.getElementById('doIt').onclick = function() {
    console.log(Notification)
    if (Notification.permission !== 'granted'){
      alert("Can't send push. Please, allow notifications");
      return;
    }
    const payload = document.getElementById('notification-payload').value;
    const delay = document.getElementById('notification-delay').value;
    const ttl = document.getElementById('notification-ttl').value;

    // Ask the server to send the client a notification (for testing purposes, in actual
    // applications the push notification is likely going to be generated by some event
    // in the server).
    fetch('./sendPush', {
      method: 'post',
      headers: {
        'Content-type': 'application/json'
      },
      body: JSON.stringify({
        subscription: subscription,
        payload: payload,
        delay: delay,
        ttl: ttl,
      }),
    });
  };

});

document.getElementById("enable-notifications").addEventListener("click", (event) => {
  event.preventDefault()

  navigator.serviceWorker.ready
  .then(registration => {
    if (!registration.pushManager) {
      alert("Push notifications not supported in this browser")
      throw new Error("Push notifications not supported in this browser");
    }
  })
  .then(() => askNotificationPermission().then(alert).then(async function() {
    await registerServiceWorker();
  }))
  .catch(e => console.error(e));
/*
  askNotificationPermission().then(alert).then(async function() {
    await registerServiceWorker();
  });
*/
})

function askNotificationPermission() {
    return new Promise((resolve, reject) => {
      if (checkNotificationPromise()) {
        Notification.requestPermission().then(resolve);

      } else {
        Notification.requestPermission(resolve)
      }
    })
  }


function checkNotificationPromise() {
    try {
      Notification.requestPermission().then();
    } catch(e) {
      return false;
    }

    return true;
  }

const registerServiceWorker = async () => {
//    alert("registering service worker");
    const swRegistration = await navigator.serviceWorker.register('service-worker.js');
//    alert(swRegistration.active);
    console.log(swRegistration);
    return swRegistration;
}